#import "std/io" as io;

// 内置函数声明
declare fun _builtin_create_string(ptr: pointer(char), len: i64): string;
declare fun _builtin_array_append(arr_ptr: pointer(array(string)), element: string): array(string);
declare fun _builtin_array_get(arr: array(string), index: i64): string;
declare fun toString(val: i64): string;

// 汇编 bootstrap 会跳转到这个入口函数
// 它接收标准的 argc 和 argv 参数，argv 是 char** (pointer(pointer(i8)))
fun _start_entry(argc: i32, argv_base_ptr: pointer(pointer(char))): i32 {
    io.output("进入 _start_entry 函数 (底层参数处理跳板)\n");

    // 声明 Yulang 风格的字符串数组，编译器会自动进行默认初始化（空数组）
    let yulang_args: array(string); 

    let i: i64 = 0;
    while (i < (argc as i64)) {
        // --- unsafe 块 (模拟底层指针操作) ---
        let current_char_ptr_addr: pointer(pointer(char)) = argv_base_ptr + (i as i64);
        let c_str_ptr: pointer(char) = *current_char_ptr_addr;

        // 内联 c_strlen 的逻辑
        let len: i64 = 0;
        while (*(c_str_ptr + len) != '\0') {
            len = len + 1;
        }
        
        // 使用获取到的长度创建 Yulang 字符串
        let arg_str: string = _builtin_create_string(c_str_ptr, len);
        
        // 将 Yulang 字符串追加到数组
        yulang_args = _builtin_array_append(&yulang_args, arg_str);
        
        i = i + 1;
    }

    io.output("转换完成，调用 main 函数...\n");
    return main(yulang_args); // 将处理后的 Yulang 参数传递给 main 函数
}

// 修改 main 函数的签名以接收 Yulang 的字符串数组参数
fun main(args: array(string)): i32 {
    io.output("hello from main! (已接收命令行参数)\n");
    io.output("命令行参数数量: ");
    io.output(toString(args.len)); // 假设 i64 可以直接转 string，或者需要 to_string 函数
    io.output("\n");

    let i: i64 = 0;
    while (i < args.len) {
        io.output("参数[");
        io.output(toString(i)); // 假设 i64 可以直接转 string
        io.output("]: ");
        // io.output(_builtin_array_get(args, i)); // 暂时注释，用于调试
        io.output("\n");
        i = i + 1;
    }

    return 0;
}